<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2018"><meta name="DC.rights.owner" content="(C) Copyright 2018"><meta name="DC.Type" content="concept"><meta name="DC.Relation" scheme="URI" content="../topics/impala_datatypes.html"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="version" content="Impala 2.12x"><meta name="version" content="Impala 2.12x"><meta name="DC.Format" content="XHTML"><meta name="DC.Identifier" content="decimal"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>DECIMAL Data Type (Impala 1.4 or higher only)</title></head><body id="decimal"><main role="main"><article role="article" aria-labelledby="ariaid-title1">

  <h1 class="title topictitle1" id="ariaid-title1">DECIMAL Data Type (<span class="keyword">Impala 1.4</span> or higher only)</h1>
  
  

  <div class="body conbody">

    <p class="p">
      A numeric data type with fixed scale and precision, used in <code class="ph codeph">CREATE TABLE</code> and <code class="ph codeph">ALTER
      TABLE</code> statements. Suitable for financial and other arithmetic calculations where the imprecise
      representation and rounding behavior of <code class="ph codeph">FLOAT</code> and <code class="ph codeph">DOUBLE</code> make those types
      impractical.
    </p>

    <p class="p">
        <strong class="ph b">Syntax:</strong>
      </p>

    <p class="p">
      In the column definition of a <code class="ph codeph">CREATE TABLE</code> statement:
    </p>

<pre class="pre codeblock"><code><var class="keyword varname">column_name</var> DECIMAL[(<var class="keyword varname">precision</var>[,<var class="keyword varname">scale</var>])]</code></pre>

    <p class="p">
      <code class="ph codeph">DECIMAL</code> with no precision or scale values is equivalent to <code class="ph codeph">DECIMAL(9,0)</code>.
    </p>

    <p class="p">
      <strong class="ph b">Precision and Scale:</strong>
    </p>

    <p class="p">
      <var class="keyword varname">precision</var> represents the total number of digits that can be represented by the column,
      regardless of the location of the decimal point. This value must be between 1 and 38. For example,
      representing integer values up to 9999, and floating-point values up to 99.99, both require a precision of 4.
      You can also represent corresponding negative values, without any change in the precision. For example, the
      range -9999 to 9999 still only requires a precision of 4.
    </p>

    <p class="p">
      <var class="keyword varname">scale</var> represents the number of fractional digits. This value must be less than or equal to
      <var class="keyword varname">precision</var>. A scale of 0 produces integral values, with no fractional part. If precision
      and scale are equal, all the digits come after the decimal point, making all the values between 0 and
      0.999... or 0 and -0.999...
    </p>

    <p class="p">
      When <var class="keyword varname">precision</var> and <var class="keyword varname">scale</var> are omitted, a <code class="ph codeph">DECIMAL</code> value
      is treated as <code class="ph codeph">DECIMAL(9,0)</code>, that is, an integer value ranging from
      <code class="ph codeph">-999,999,999</code> to <code class="ph codeph">999,999,999</code>. This is the largest <code class="ph codeph">DECIMAL</code>
      value that can still be represented in 4 bytes. If precision is specified but scale is omitted, Impala uses a
      value of zero for the scale.
    </p>

    <p class="p">
      Both <var class="keyword varname">precision</var> and <var class="keyword varname">scale</var> must be specified as integer literals, not any
      other kind of constant expressions.
    </p>

    <p class="p">
      To check the precision or scale for arbitrary values, you can call the
      <a class="xref" href="impala_math_functions.html#math_functions"><code class="ph codeph">precision()</code> and
      <code class="ph codeph">scale()</code> built-in functions</a>. For example, you might use these values to figure out how
      many characters are required for various fields in a report, or to understand the rounding characteristics of
      a formula as applied to a particular <code class="ph codeph">DECIMAL</code> column.
    </p>

    <p class="p">
      <strong class="ph b">Range:</strong>
    </p>

    <p class="p">
      The maximum precision value is 38. Thus, the largest integral value is represented by
      <code class="ph codeph">DECIMAL(38,0)</code> (999... with 9 repeated 38 times). The most precise fractional value (between
      0 and 1, or 0 and -1) is represented by <code class="ph codeph">DECIMAL(38,38)</code>, with 38 digits to the right of the
      decimal point. The value closest to 0 would be .0000...1 (37 zeros and the final 1). The value closest to 1
      would be .999... (9 repeated 38 times).
    </p>

    <p class="p">
      For a given precision and scale, the range of <code class="ph codeph">DECIMAL</code> values is the same in the positive and
      negative directions. For example, <code class="ph codeph">DECIMAL(4,2)</code> can represent from -99.99 to 99.99. This is
      different from other integral numeric types where the positive and negative bounds differ slightly.
    </p>

    <p class="p">
      When you use <code class="ph codeph">DECIMAL</code> values in arithmetic expressions, the precision and scale of the result
      value are determined as follows:
    </p>

    <ul class="ul">
      <li class="li">
        <p class="p">
          For addition and subtraction, the precision and scale are based on the maximum possible result, that is,
          if all the digits of the input values were 9s and the absolute values were added together.
        </p>


      </li>

      <li class="li">
        <p class="p">
          For multiplication, the precision is the sum of the precisions of the input values. The scale is the sum
          of the scales of the input values.
        </p>
      </li>



      <li class="li">
        <p class="p">
          For division, Impala sets the precision and scale to values large enough to represent the whole and
          fractional parts of the result.
        </p>
      </li>

      <li class="li">
        <p class="p">
          For <code class="ph codeph">UNION</code>, the scale is the larger of the scales of the input values, and the precision
          is increased if necessary to accommodate any additional fractional digits. If the same input value has
          the largest precision and the largest scale, the result value has the same precision and scale. If one
          value has a larger precision but smaller scale, the scale of the result value is increased. For example,
          <code class="ph codeph">DECIMAL(20,2) UNION DECIMAL(8,6)</code> produces a result of type
          <code class="ph codeph">DECIMAL(24,6)</code>. The extra 4 fractional digits of scale (6-2) are accommodated by
          extending the precision by the same amount (20+4).
        </p>
      </li>

      <li class="li">
        <p class="p">
          To doublecheck, you can always call the <code class="ph codeph">PRECISION()</code> and <code class="ph codeph">SCALE()</code>
          functions on the results of an arithmetic expression to see the relevant values, or use a <code class="ph codeph">CREATE
          TABLE AS SELECT</code> statement to define a column based on the return type of the expression.
        </p>
      </li>
    </ul>

    <p class="p">
        <strong class="ph b">Compatibility:</strong>
      </p>

    <ul class="ul">
      <li class="li">
        Using the <code class="ph codeph">DECIMAL</code> type is only supported under <span class="keyword">Impala 1.4</span> and higher.
      </li>

      <li class="li">
        Use the <code class="ph codeph">DECIMAL</code> data type in Impala for applications where you used the
        <code class="ph codeph">NUMBER</code> data type in Oracle. The Impala <code class="ph codeph">DECIMAL</code> type does not support the
        Oracle idioms of <code class="ph codeph">*</code> for scale or negative values for precision.
      </li>
    </ul>

    <p class="p">
      <strong class="ph b">Conversions and casting:</strong>
    </p>

    <p class="p">
      <span class="ph">
          Casting an integer or floating-point value <code class="ph codeph">N</code> to
        <code class="ph codeph">TIMESTAMP</code> produces a value that is <code class="ph codeph">N</code> seconds past the start of the epoch
        date (January 1, 1970). By default, the result value represents a date and time in the UTC time zone.
        If the setting <code class="ph codeph">--use_local_tz_for_unix_timestamp_conversions=true</code> is in effect,
        the resulting <code class="ph codeph">TIMESTAMP</code> represents a date and time in the local time zone.
        </span>
    </p>

    <p class="p">
      Impala automatically converts between <code class="ph codeph">DECIMAL</code> and other numeric types where possible. A
      <code class="ph codeph">DECIMAL</code> with zero scale is converted to or from the smallest appropriate integral type. A
      <code class="ph codeph">DECIMAL</code> with a fractional part is automatically converted to or from the smallest
      appropriate floating-point type. If the destination type does not have sufficient precision or scale to hold
      all possible values of the source type, Impala raises an error and does not convert the value.
    </p>

    <p class="p">
      For example, these statements show how expressions of <code class="ph codeph">DECIMAL</code> and other types are reconciled
      to the same type in the context of <code class="ph codeph">UNION</code> queries and <code class="ph codeph">INSERT</code> statements:
    </p>

<pre class="pre codeblock"><code>[localhost:21000] &gt; select cast(1 as int) as x union select cast(1.5 as decimal(9,4)) as x;
+----------------+
| x              |
+----------------+
| 1.5000         |
| 1.0000         |
+----------------+
[localhost:21000] &gt; create table int_vs_decimal as select cast(1 as int) as x union select cast(1.5 as decimal(9,4)) as x;
+-------------------+
| summary           |
+-------------------+
| Inserted 2 row(s) |
+-------------------+
[localhost:21000] &gt; desc int_vs_decimal;
+------+---------------+---------+
| name | type          | comment |
+------+---------------+---------+
| x    | decimal(14,4) |         |
+------+---------------+---------+

</code></pre>

    <p class="p">
      To avoid potential conversion errors, you can use <code class="ph codeph">CAST()</code> to convert <code class="ph codeph">DECIMAL</code>
      values to <code class="ph codeph">FLOAT</code>, <code class="ph codeph">TINYINT</code>, <code class="ph codeph">SMALLINT</code>, <code class="ph codeph">INT</code>,
      <code class="ph codeph">BIGINT</code>, <code class="ph codeph">STRING</code>, <code class="ph codeph">TIMESTAMP</code>, or <code class="ph codeph">BOOLEAN</code>.
      You can use exponential notation in <code class="ph codeph">DECIMAL</code> literals or when casting from
      <code class="ph codeph">STRING</code>, for example <code class="ph codeph">1.0e6</code> to represent one million.
    </p>

    <p class="p">
      If you cast a value with more fractional digits than the scale of the destination type, any extra fractional
      digits are truncated (not rounded). Casting a value to a target type with not enough precision produces a
      result of <code class="ph codeph">NULL</code> and displays a runtime warning.
    </p>

<pre class="pre codeblock"><code>[localhost:21000] &gt; select cast(1.239 as decimal(3,2));
+-----------------------------+
| cast(1.239 as decimal(3,2)) |
+-----------------------------+
| 1.23                        |
+-----------------------------+
[localhost:21000] &gt; select cast(1234 as decimal(3));
+----------------------------+
| cast(1234 as decimal(3,0)) |
+----------------------------+
| NULL                       |
+----------------------------+
WARNINGS: Expression overflowed, returning NULL

</code></pre>

    <p class="p">
      When you specify integer literals, for example in <code class="ph codeph">INSERT ... VALUES</code> statements or arithmetic
      expressions, those numbers are interpreted as the smallest applicable integer type. You must use
      <code class="ph codeph">CAST()</code> calls for some combinations of integer literals and <code class="ph codeph">DECIMAL</code>
      precision. For example, <code class="ph codeph">INT</code> has a maximum value that is 10 digits long,
      <code class="ph codeph">TINYINT</code> has a maximum value that is 3 digits long, and so on. If you specify a value such as
      123456 to go into a <code class="ph codeph">DECIMAL</code> column, Impala checks if the column has enough precision to
      represent the largest value of that integer type, and raises an error if not. Therefore, use an expression
      like <code class="ph codeph">CAST(123456 TO DECIMAL(9,0))</code> for <code class="ph codeph">DECIMAL</code> columns with precision 9 or
      less, <code class="ph codeph">CAST(50 TO DECIMAL(2,0))</code> for <code class="ph codeph">DECIMAL</code> columns with precision 2 or
      less, and so on. For <code class="ph codeph">DECIMAL</code> columns with precision 10 or greater, Impala automatically
      interprets the value as the correct <code class="ph codeph">DECIMAL</code> type; however, because
      <code class="ph codeph">DECIMAL(10)</code> requires 8 bytes of storage while <code class="ph codeph">DECIMAL(9)</code> requires only 4
      bytes, only use precision of 10 or higher when actually needed.
    </p>

<pre class="pre codeblock"><code>[localhost:21000] &gt; create table decimals_9_0 (x decimal);
[localhost:21000] &gt; insert into decimals_9_0 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000);
ERROR: AnalysisException: Possible loss of precision for target table 'decimal_testing.decimals_9_0'.
Expression '1' (type: INT) would need to be cast to DECIMAL(9,0) for column 'x'
[localhost:21000] &gt; insert into decimals_9_0 values (cast(1 as decimal)), (cast(2 as decimal)), (cast(4 as decimal)), (cast(8 as decimal)), (cast(16 as decimal)), (cast(1024 as decimal)), (cast(32768 as decimal)), (cast(65536 as decimal)), (cast(1000000 as decimal));

[localhost:21000] &gt; create table decimals_10_0 (x decimal(10,0));
[localhost:21000] &gt; insert into decimals_10_0 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000);

</code></pre>

    <p class="p">
      Be aware that in memory and for binary file formats such as Parquet or Avro, <code class="ph codeph">DECIMAL(10)</code> or
      higher consumes 8 bytes while <code class="ph codeph">DECIMAL(9)</code> (the default for <code class="ph codeph">DECIMAL</code>) or lower
      consumes 4 bytes. Therefore, to conserve space in large tables, use the smallest-precision
      <code class="ph codeph">DECIMAL</code> type that is appropriate and <code class="ph codeph">CAST()</code> literal values where necessary,
      rather than declaring <code class="ph codeph">DECIMAL</code> columns with high precision for convenience.
    </p>

    <p class="p">
      To represent a very large or precise <code class="ph codeph">DECIMAL</code> value as a literal, for example one that
      contains more digits than can be represented by a <code class="ph codeph">BIGINT</code> literal, use a quoted string or a
      floating-point value for the number, and <code class="ph codeph">CAST()</code> to the desired <code class="ph codeph">DECIMAL</code>
      type:
    </p>

<pre class="pre codeblock"><code>insert into decimals_38_5 values (1), (2), (4), (8), (16), (1024), (32768), (65536), (1000000),
  (cast("999999999999999999999999999999" as decimal(38,5))),
  (cast(999999999999999999999999999999. as decimal(38,5)));
</code></pre>

    <ul class="ul">
      <li class="li">
        <p class="p"> The result of the <code class="ph codeph">SUM()</code> aggregate function on
            <code class="ph codeph">DECIMAL</code> values is promoted to a precision of 38,
          with the same precision as the underlying column. Thus, the result can
          represent the largest possible value at that particular precision. </p>
      </li>

      <li class="li">
        <p class="p">
          <code class="ph codeph">STRING</code> columns, literals, or expressions can be converted to <code class="ph codeph">DECIMAL</code> as
          long as the overall number of digits and digits to the right of the decimal point fit within the
          specified precision and scale for the declared <code class="ph codeph">DECIMAL</code> type. By default, a
          <code class="ph codeph">DECIMAL</code> value with no specified scale or precision can hold a maximum of 9 digits of an
          integer value. If there are more digits in the string value than are allowed by the
          <code class="ph codeph">DECIMAL</code> scale and precision, the result is <code class="ph codeph">NULL</code>.
        </p>
        <p class="p">
          The following examples demonstrate how <code class="ph codeph">STRING</code> values with integer and fractional parts
          are represented when converted to <code class="ph codeph">DECIMAL</code>. If the scale is 0, the number is treated
          as an integer value with a maximum of <var class="keyword varname">precision</var> digits. If the precision is greater than
          0, the scale must be increased to account for the digits both to the left and right of the decimal point.
          As the precision increases, output values are printed with additional trailing zeros after the decimal
          point if needed. Any trailing zeros after the decimal point in the <code class="ph codeph">STRING</code> value must fit
          within the number of digits specified by the precision.
        </p>
<pre class="pre codeblock"><code>[localhost:21000] &gt; select cast('100' as decimal); -- Small integer value fits within 9 digits of scale.
+-----------------------------+
| cast('100' as decimal(9,0)) |
+-----------------------------+
| 100                         |
+-----------------------------+
[localhost:21000] &gt; select cast('100' as decimal(3,0)); -- Small integer value fits within 3 digits of scale.
+-----------------------------+
| cast('100' as decimal(3,0)) |
+-----------------------------+
| 100                         |
+-----------------------------+
[localhost:21000] &gt; select cast('100' as decimal(2,0)); -- 2 digits of scale is not enough!
+-----------------------------+
| cast('100' as decimal(2,0)) |
+-----------------------------+
| NULL                        |
+-----------------------------+
[localhost:21000] &gt; select cast('100' as decimal(3,1)); -- (3,1) = 2 digits left of the decimal point, 1 to the right. Not enough.
+-----------------------------+
| cast('100' as decimal(3,1)) |
+-----------------------------+
| NULL                        |
+-----------------------------+
[localhost:21000] &gt; select cast('100' as decimal(4,1)); -- 4 digits total, 1 to the right of the decimal point.
+-----------------------------+
| cast('100' as decimal(4,1)) |
+-----------------------------+
| 100.0                       |
+-----------------------------+
[localhost:21000] &gt; select cast('98.6' as decimal(3,1)); -- (3,1) can hold a 3 digit number with 1 fractional digit.
+------------------------------+
| cast('98.6' as decimal(3,1)) |
+------------------------------+
| 98.6                         |
+------------------------------+
[localhost:21000] &gt; select cast('98.6' as decimal(15,1)); -- Larger scale allows bigger numbers but still only 1 fractional digit.
+-------------------------------+
| cast('98.6' as decimal(15,1)) |
+-------------------------------+
| 98.6                          |
+-------------------------------+
[localhost:21000] &gt; select cast('98.6' as decimal(15,5)); -- Larger precision allows more fractional digits, outputs trailing zeros.
+-------------------------------+
| cast('98.6' as decimal(15,5)) |
+-------------------------------+
| 98.60000                      |
+-------------------------------+
[localhost:21000] &gt; select cast('98.60000' as decimal(15,1)); -- Trailing zeros in the string must fit within 'scale' digits (1 in this case).
+-----------------------------------+
| cast('98.60000' as decimal(15,1)) |
+-----------------------------------+
| NULL                              |
+-----------------------------------+

</code></pre>
      </li>

      <li class="li">
        Most built-in arithmetic functions such as <code class="ph codeph">SIN()</code> and <code class="ph codeph">COS()</code> continue to
        accept only <code class="ph codeph">DOUBLE</code> values because they are so commonly used in scientific context for
        calculations of IEEE 954-compliant values. The built-in functions that accept and return
        <code class="ph codeph">DECIMAL</code> are:


        <ul class="ul">
          <li class="li">
            <code class="ph codeph">ABS()</code>
          </li>

          <li class="li">
            <code class="ph codeph">CEIL()</code>
          </li>

          <li class="li">
            <code class="ph codeph">COALESCE()</code>
          </li>

          <li class="li">
            <code class="ph codeph">FLOOR()</code>
          </li>

          <li class="li">
            <code class="ph codeph">FNV_HASH()</code>
          </li>

          <li class="li">
            <code class="ph codeph">GREATEST()</code>
          </li>

          <li class="li">
            <code class="ph codeph">IF()</code>
          </li>

          <li class="li">
            <code class="ph codeph">ISNULL()</code>
          </li>

          <li class="li">
            <code class="ph codeph">LEAST()</code>
          </li>

          <li class="li">
            <code class="ph codeph">NEGATIVE()</code>
          </li>

          <li class="li">
            <code class="ph codeph">NULLIF()</code>
          </li>

          <li class="li">
            <code class="ph codeph">POSITIVE()</code>
          </li>

          <li class="li">
            <code class="ph codeph">PRECISION()</code>
          </li>

          <li class="li">
            <code class="ph codeph">ROUND()</code>
          </li>

          <li class="li">
            <code class="ph codeph">SCALE()</code>
          </li>

          <li class="li">
            <code class="ph codeph">TRUNCATE()</code>
          </li>

          <li class="li">
            <code class="ph codeph">ZEROIFNULL()</code>
          </li>
        </ul>
        See <a class="xref" href="impala_functions.html#builtins">Impala Built-In Functions</a> for details.
      </li>

      <li class="li">
        <p class="p">
          <code class="ph codeph">BIGINT</code>, <code class="ph codeph">INT</code>, <code class="ph codeph">SMALLINT</code>, and <code class="ph codeph">TINYINT</code>
          values can all be cast to <code class="ph codeph">DECIMAL</code>. The number of digits to the left of the decimal point
          in the <code class="ph codeph">DECIMAL</code> type must be sufficient to hold the largest value of the corresponding
          integer type. Note that integer literals are treated as the smallest appropriate integer type, meaning
          there is sometimes a range of values that require one more digit of <code class="ph codeph">DECIMAL</code> scale than
          you might expect. For integer values, the precision of the <code class="ph codeph">DECIMAL</code> type can be zero; if
          the precision is greater than zero, remember to increase the scale value by an equivalent amount to hold
          the required number of digits to the left of the decimal point.
        </p>
        <p class="p">
          The following examples show how different integer types are converted to <code class="ph codeph">DECIMAL</code>.
        </p>

<pre class="pre codeblock"><code>[localhost:21000] &gt; select cast(1 as decimal(1,0));
+-------------------------+
| cast(1 as decimal(1,0)) |
+-------------------------+
| 1                       |
+-------------------------+
[localhost:21000] &gt; select cast(9 as decimal(1,0));
+-------------------------+
| cast(9 as decimal(1,0)) |
+-------------------------+
| 9                       |
+-------------------------+
[localhost:21000] &gt; select cast(10 as decimal(1,0));
+--------------------------+
| cast(10 as decimal(1,0)) |
+--------------------------+
| 10                       |
+--------------------------+
[localhost:21000] &gt; select cast(10 as decimal(1,1));
+--------------------------+
| cast(10 as decimal(1,1)) |
+--------------------------+
| 10.0                     |
+--------------------------+
[localhost:21000] &gt; select cast(100 as decimal(1,1));
+---------------------------+
| cast(100 as decimal(1,1)) |
+---------------------------+
| 100.0                     |
+---------------------------+
[localhost:21000] &gt; select cast(1000 as decimal(1,1));
+----------------------------+
| cast(1000 as decimal(1,1)) |
+----------------------------+
| 1000.0                     |
+----------------------------+

</code></pre>
      </li>

      <li class="li">
        <p class="p">
          When a <code class="ph codeph">DECIMAL</code> value is converted to any of the integer types, any fractional part is
          truncated (that is, rounded towards zero):
        </p>
<pre class="pre codeblock"><code>[localhost:21000] &gt; create table num_dec_days (x decimal(4,1));
[localhost:21000] &gt; insert into num_dec_days values (1), (2), (cast(4.5 as decimal(4,1)));
[localhost:21000] &gt; insert into num_dec_days values (cast(0.1 as decimal(4,1))), (cast(.9 as decimal(4,1))), (cast(9.1 as decimal(4,1))), (cast(9.9 as decimal(4,1)));
[localhost:21000] &gt; select cast(x as int) from num_dec_days;
+----------------+
| cast(x as int) |
+----------------+
| 1              |
| 2              |
| 4              |
| 0              |
| 0              |
| 9              |
| 9              |
+----------------+

</code></pre>
      </li>

      <li class="li">
        <p class="p">
          You cannot directly cast <code class="ph codeph">TIMESTAMP</code> or <code class="ph codeph">BOOLEAN</code> values to or from
          <code class="ph codeph">DECIMAL</code> values. You can turn a <code class="ph codeph">DECIMAL</code> value into a time-related
          representation using a two-step process, by converting it to an integer value and then using that result
          in a call to a date and time function such as <code class="ph codeph">from_unixtime()</code>.
        </p>
<pre class="pre codeblock"><code>[localhost:21000] &gt; select from_unixtime(cast(cast(1000.0 as decimal) as bigint));
+-------------------------------------------------------------+
| from_unixtime(cast(cast(1000.0 as decimal(9,0)) as bigint)) |
+-------------------------------------------------------------+
| 1970-01-01 00:16:40                                         |
+-------------------------------------------------------------+
[localhost:21000] &gt; select now() + interval cast(x as int) days from num_dec_days; -- x is a DECIMAL column.

[localhost:21000] &gt; create table num_dec_days (x decimal(4,1));
[localhost:21000] &gt; insert into num_dec_days values (1), (2), (cast(4.5 as decimal(4,1)));
[localhost:21000] &gt; select now() + interval cast(x as int) days from num_dec_days; -- The 4.5 value is truncated to 4 and becomes '4 days'.
+--------------------------------------+
| now() + interval cast(x as int) days |
+--------------------------------------+
| 2014-05-13 23:11:55.163284000        |
| 2014-05-14 23:11:55.163284000        |
| 2014-05-16 23:11:55.163284000        |
+--------------------------------------+

</code></pre>
      </li>

      <li class="li">
        <p class="p">
          Because values in <code class="ph codeph">INSERT</code> statements are checked rigorously for type compatibility, be
          prepared to use <code class="ph codeph">CAST()</code> function calls around literals, column references, or other
          expressions that you are inserting into a <code class="ph codeph">DECIMAL</code> column.
        </p>
      </li>
    </ul>

    <p class="p">
        <strong class="ph b">NULL considerations:</strong> Casting any non-numeric value to this type produces a <code class="ph codeph">NULL</code>
        value.
      </p>

    <p class="p">
      <strong class="ph b">DECIMAL differences from integer and floating-point types:</strong>
    </p>

    <p class="p">
      With the <code class="ph codeph">DECIMAL</code> type, you are concerned with the number of overall digits of a number
      rather than powers of 2 (as in <code class="ph codeph">TINYINT</code>, <code class="ph codeph">SMALLINT</code>, and so on). Therefore,
      the limits with integral values of <code class="ph codeph">DECIMAL</code> types fall around 99, 999, 9999, and so on rather
      than 32767, 65535, 2
      <sup class="ph sup">32</sup>
      -1, and so on. For fractional values, you do not need to account for imprecise representation of the
      fractional part according to the IEEE-954 standard (as in <code class="ph codeph">FLOAT</code> and
      <code class="ph codeph">DOUBLE</code>). Therefore, when you insert a fractional value into a <code class="ph codeph">DECIMAL</code>
      column, you can compare, sum, query, <code class="ph codeph">GROUP BY</code>, and so on that column and get back the
      original values rather than some <span class="q">"close but not identical"</span> value.
    </p>

    <p class="p">
      <code class="ph codeph">FLOAT</code> and <code class="ph codeph">DOUBLE</code> can cause problems or unexpected behavior due to inability
      to precisely represent certain fractional values, for example dollar and cents values for currency. You might
      find output values slightly different than you inserted, equality tests that do not match precisely, or
      unexpected values for <code class="ph codeph">GROUP BY</code> columns. <code class="ph codeph">DECIMAL</code> can help reduce unexpected
      behavior and rounding errors, at the expense of some performance overhead for assignments and comparisons.
    </p>

    <div class="p">
      <strong class="ph b">Literals and expressions:</strong>
      <ul class="ul">
        <li class="li">
          <p class="p">
            When you use an integer literal such as <code class="ph codeph">1</code> or <code class="ph codeph">999</code> in a SQL statement,
            depending on the context, Impala will treat it as either the smallest appropriate
            <code class="ph codeph">DECIMAL</code> type, or the smallest integer type (<code class="ph codeph">TINYINT</code>,
            <code class="ph codeph">SMALLINT</code>, <code class="ph codeph">INT</code>, or <code class="ph codeph">BIGINT</code>). To minimize memory usage,
            Impala prefers to treat the literal as the smallest appropriate integer type.
          </p>
        </li>

        <li class="li">
          <p class="p">
            When you use a floating-point literal such as <code class="ph codeph">1.1</code> or <code class="ph codeph">999.44</code> in a SQL
            statement, depending on the context, Impala will treat it as either the smallest appropriate
            <code class="ph codeph">DECIMAL</code> type, or the smallest floating-point type (<code class="ph codeph">FLOAT</code> or
            <code class="ph codeph">DOUBLE</code>). To avoid loss of accuracy, Impala prefers to treat the literal as a
            <code class="ph codeph">DECIMAL</code>.
          </p>
        </li>
      </ul>
    </div>

    <p class="p">
      <strong class="ph b">Storage considerations:</strong>
    </p>

    <ul class="ul">
      <li class="li">
        Only the precision determines the storage size for <code class="ph codeph">DECIMAL</code> values; the scale setting has
        no effect on the storage size.
      </li>

      <li class="li">
        Text, RCFile, and SequenceFile tables all use ASCII-based formats. In these text-based file formats,
        leading zeros are not stored, but trailing zeros are stored. In these tables, each <code class="ph codeph">DECIMAL</code>
        value takes up as many bytes as there are digits in the value, plus an extra byte if the decimal point is
        present and an extra byte for negative values. Once the values are loaded into memory, they are represented
        in 4, 8, or 16 bytes as described in the following list items. The on-disk representation varies depending
        on the file format of the table.
      </li>



      <li class="li">
        Parquet and Avro tables use binary formats, In these tables, Impala stores each value in as few bytes as
        possible

        depending on the precision specified for the <code class="ph codeph">DECIMAL</code> column.
        <ul class="ul">
          <li class="li">
            In memory, <code class="ph codeph">DECIMAL</code> values with precision of 9 or less are stored in 4 bytes.
          </li>

          <li class="li">
            In memory, <code class="ph codeph">DECIMAL</code> values with precision of 10 through 18 are stored in 8 bytes.
          </li>

          <li class="li">
            In memory, <code class="ph codeph">DECIMAL</code> values with precision greater than 18 are stored in 16 bytes.
          </li>
        </ul>
      </li>
    </ul>

    <p class="p">
        <strong class="ph b">File format considerations:</strong>
      </p>

    <ul class="ul">
      <li class="li">
        The <code class="ph codeph">DECIMAL</code> data type can be stored in any of the file formats supported by Impala, as
        described in <a class="xref" href="impala_file_formats.html#file_formats">How Impala Works with Hadoop File Formats</a>. Impala only writes to tables that use the
        Parquet and text formats, so those formats are the focus for file format compatibility.
      </li>

      <li class="li">
        Impala can query Avro, RCFile, or SequenceFile tables containing <code class="ph codeph">DECIMAL</code> columns, created
        by other Hadoop components.
      </li>

      <li class="li">
        You can use <code class="ph codeph">DECIMAL</code> columns in Impala tables that are mapped to HBase tables. Impala can
        query and insert into such tables.
      </li>

      <li class="li">
        Text, RCFile, and SequenceFile tables all use ASCII-based formats. In these tables, each
        <code class="ph codeph">DECIMAL</code> value takes up as many bytes as there are digits in the value, plus an extra byte
        if the decimal point is present. The binary format of Parquet or Avro files offers more compact storage for
        <code class="ph codeph">DECIMAL</code> columns.
      </li>

      <li class="li">
        Parquet and Avro tables use binary formats, In these tables, Impala stores each value in 4, 8, or 16 bytes
        depending on the precision specified for the <code class="ph codeph">DECIMAL</code> column.
      </li>

    </ul>

    <p class="p">
      <strong class="ph b">UDF considerations:</strong> When writing a C++ UDF, use the <code class="ph codeph">DecimalVal</code> data type defined in
      <span class="ph filepath">/usr/include/impala_udf/udf.h</span>.
    </p>

    <p class="p">
        <strong class="ph b">Partitioning:</strong>
      </p>

    <p class="p">
      You can use a <code class="ph codeph">DECIMAL</code> column as a partition key. Doing so provides a better match between
      the partition key values and the HDFS directory names than using a <code class="ph codeph">DOUBLE</code> or
      <code class="ph codeph">FLOAT</code> partitioning column:
    </p>

    <p class="p">
        <strong class="ph b">Schema evolution considerations:</strong>
      </p>

    <ul class="ul">
      <li class="li">
        For text-based formats (text, RCFile, and SequenceFile tables), you can issue an <code class="ph codeph">ALTER TABLE ...
        REPLACE COLUMNS</code> statement to change the precision and scale of an existing
        <code class="ph codeph">DECIMAL</code> column. As long as the values in the column fit within the new precision and
        scale, they are returned correctly by a query. Any values that do not fit within the new precision and
        scale are returned as <code class="ph codeph">NULL</code>, and Impala reports the conversion error. Leading zeros do not
        count against the precision value, but trailing zeros after the decimal point do.
<pre class="pre codeblock"><code>[localhost:21000] &gt; create table text_decimals (x string);
[localhost:21000] &gt; insert into text_decimals values ("1"), ("2"), ("99.99"), ("1.234"), ("000001"), ("1.000000000");
[localhost:21000] &gt; select * from text_decimals;
+-------------+
| x           |
+-------------+
| 1           |
| 2           |
| 99.99       |
| 1.234       |
| 000001      |
| 1.000000000 |
+-------------+
[localhost:21000] &gt; alter table text_decimals replace columns (x decimal(4,2));
[localhost:21000] &gt; select * from text_decimals;
+-------+
| x     |
+-------+
| 1.00  |
| 2.00  |
| 99.99 |
| NULL  |
| 1.00  |
| NULL  |
+-------+
ERRORS:
Backend 0:Error converting column: 0 TO DECIMAL(4, 2) (Data is: 1.234)
file: hdfs://127.0.0.1:8020/user/hive/warehouse/decimal_testing.db/text_decimals/634d4bd3aa0
e8420-b4b13bab7f1be787_56794587_data.0
record: 1.234
Error converting column: 0 TO DECIMAL(4, 2) (Data is: 1.000000000)
file: hdfs://127.0.0.1:8020/user/hive/warehouse/decimal_testing.db/text_decimals/cd40dc68e20
c565a-cc4bd86c724c96ba_311873428_data.0
record: 1.000000000

</code></pre>
      </li>

      <li class="li">
        For binary formats (Parquet and Avro tables), although an <code class="ph codeph">ALTER TABLE ... REPLACE COLUMNS</code>
        statement that changes the precision or scale of a <code class="ph codeph">DECIMAL</code> column succeeds, any subsequent
        attempt to query the changed column results in a fatal error. (The other columns can still be queried
        successfully.) This is because the metadata about the columns is stored in the data files themselves, and
        <code class="ph codeph">ALTER TABLE</code> does not actually make any updates to the data files. If the metadata in the
        data files disagrees with the metadata in the metastore database, Impala cancels the query.
      </li>
    </ul>

    <p class="p">
        <strong class="ph b">Examples:</strong>
      </p>

<pre class="pre codeblock"><code>CREATE TABLE t1 (x DECIMAL, y DECIMAL(5,2), z DECIMAL(25,0));
INSERT INTO t1 VALUES (5, 99.44, 123456), (300, 6.7, 999999999);
SELECT x+y, ROUND(y,1), z/98.6 FROM t1;
SELECT CAST(1000.5 AS DECIMAL);
</code></pre>



    <p class="p">
        <strong class="ph b">HBase considerations:</strong> This data type is fully compatible with HBase tables.
      </p>

    <p class="p">
        <strong class="ph b">Parquet considerations:</strong> This type is fully compatible with Parquet tables.
      </p>

    <p class="p">
        <strong class="ph b">Text table considerations:</strong> Values of this type are potentially larger in text tables than in tables
        using Parquet or other binary formats.
      </p>







    <p class="p">
        <strong class="ph b">Column statistics considerations:</strong> Because this type has a fixed size, the maximum and average size
        fields are always filled in for column statistics, even before you run the <code class="ph codeph">COMPUTE STATS</code>
        statement.
      </p>

    <p class="p">
        <strong class="ph b">Kudu considerations:</strong>
      </p>
    <p class="p">
        Currently, the data types <code class="ph codeph">CHAR</code>, <code class="ph codeph">VARCHAR</code>,
        <code class="ph codeph">ARRAY</code>, <code class="ph codeph">MAP</code>, and <code class="ph codeph">STRUCT</code> cannot be used with Kudu tables.
      </p>

    <p class="p">
        <strong class="ph b">Related information:</strong>
      </p>

    <p class="p">
      <a class="xref" href="impala_literals.html#numeric_literals">Numeric Literals</a>, <a class="xref" href="impala_tinyint.html#tinyint">TINYINT Data Type</a>,
      <a class="xref" href="impala_smallint.html#smallint">SMALLINT Data Type</a>, <a class="xref" href="impala_int.html#int">INT Data Type</a>,
      <a class="xref" href="impala_bigint.html#bigint">BIGINT Data Type</a>, <a class="xref" href="impala_decimal.html#decimal">DECIMAL Data Type (Impala 1.4 or higher only)</a>,
      <a class="xref" href="impala_math_functions.html#math_functions">Impala Mathematical Functions</a> (especially <code class="ph codeph">PRECISION()</code> and
      <code class="ph codeph">SCALE()</code>)
    </p>
  </div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_datatypes.html">Data Types</a></div></div></nav></article></main></body></html>